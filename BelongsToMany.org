#+title: BelongsToMany
#+auther: kenjirofukuda
#+options: toc:nil num:nil ^:nil
#+HTML_HEAD_EXTRA: <style> .figure p {text-align: left;}</style>
#+HTML_HEAD_EXTRA: <script src="https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js"></script>

- @see [[https://laracasts.com/series/30-days-to-learn-laravel-11/episodes/12]]

多対多の関係を正しく理解しているか？

* 自分なりの解釈

| 立場           | 立場1         | 立場2         |
|----------------+---------------+---------------|
| 上下関係がある | *Employer*    | *Job*         |
|                | hasMany       | belongsTo     |
|----------------+---------------+---------------|
| 対等である     | *Job*         | *Tag*         |
|                | belongsTomany | belongsTomany |

#+BEGIN_EXPORT html
<pre class="mermaid">
erDiagram
	direction LR
	Employer {
	}
	Job {
	}
	Tag {
	}
	Employer||--|{Job:""
	Job}|--|{Tag:""
</pre>
#+END_EXPORT

#+begin_src mermaid :tangle no :eval no-export :file er.svg
erDiagram
	direction LR
	Employer {
	}
	Job {
	}
	Tag {
	}
	Employer||--|{Job:""
	Job}|--|{Tag:""
#+end_src

そもそもリレーショナル・データベースでは多対多は中間テーブルを採用するのがセオリーである。

* ログ

まずは、存在しないエンティティ Tag の追加
#+begin_src bash
  $ artisan make:model -mf     # migrate, and factory
#+end_src

#+begin_example
   INFO  Model [app/Models/Tag.php] created successfully.

   INFO  Factory [database/factories/TagFactory.php] created successfully.

   INFO  Migration [database/migrations/2025_10_22_005338_create_tags_table.php] created successfully.
#+end_example

Tagのマイグレーションにフィールド ~name~ を追加

次に JobとTagを関連付けるためのテーブルを定義する。規約により互いの単数形をアンダースコアで接続したテーブル名を採用する。
ここでは ~job_tag~ となる。

マイグレーションファイルの up() に以下を追加
#+begin_src php
        // PIVOT between Job and Tag
        Schema::create('job_tag', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(App\Models\Job::class, 'job_listing_id');
            $table->foreignIdFor(App\Models\Tag::class);
            $table->timestamps();
        });
#+end_src

ここで反映させるため、artisan migrate を実行

#+begin_src bash :tangle no :results raw
 test "lara1" = $(basename $(echo $PWD)) && artisan migrate
#+end_src


tags
| id | name        |
|----+-------------|
|  1 | programming |


job_tag
| id | job_listing_id | tag_id |
|----+----------------+--------|
|  1 |             10 |      1 |

今、job_tag が tag_id = 1 としてリンク情報を保持していても、tags.id = 1 が削除できてしまう。
これではデータの整合性が取れない。何らかの対策が必要

#+begin_src diff
@@ -20,8 +20,8 @@ public function up(): void
         // PIVOT between Job and Tag
         Schema::create('job_tag', function (Blueprint $table) {
             $table->id();
-            $table->foreignIdFor(App\Models\Job::class, 'job_listing_id');
-            $table->foreignIdFor(App\Models\Tag::class);
+            $table->foreignIdFor(App\Models\Job::class, 'job_listing_id')->constraind()->cascadeOnDelete();
+            $table->foreignIdFor(App\Models\Tag::class)->constraind()->cascadeOnDelete();
             $table->timestamps();
         });
     }
#+end_src

両方のフィールドに =constrained()->cascadeOnDelete()= を付加

| ラッパー        | 実態                        |                                                                                    |
|-----------------+-----------------------------+------------------------------------------------------------------------------------|
| constrained()   | constrained('job_listings') |                                                                                    |
| cascadeOnDelete | deleteOn('cascade')         | 親テーブルのデータの削除に伴い、それを外部キーとしているデータも削除するという制約 |


upにjob_tagを追加したのでdown側も対応をとる必要があります。
#+begin_src diff
@@ -32,5 +32,6 @@ public function up(): void
     public function down(): void
     {
         Schema::dropIfExists('tags');
+        Schema::dropIfExists('job_tag');
     }
 };
#+end_src

定義が完了したのでここで一度更新します。

#+begin_src bash :tangle no :results org
 test "lara1" = $(basename $(echo $PWD)) && artisan migrate:rollback && artisan migrate
#+end_src

#+RESULTS:
#+begin_src org

   INFO  Rolling back migrations.

  2025_10_22_005338_create_tags_table ........................... 19.78ms DONE


   INFO  Running migrations.

  2025_10_22_005338_create_tags_table ........................... 22.40ms DONE

#+end_src


ここまでしても、まだ関連するレコードが削除できてしまいます。

#+begin_src bash :results raw :tangle yes :eval no-export
sqlite3 ./database/database.sqlite <<EOF
.mode table
PRAGMA table_info(job_tag);
.quit
EOF
#+end_src

| cid | name           | type     | notnull | dflt_value | pk |
|-----+----------------+----------+---------+------------+----|
|   0 | id             | INTEGER  |       1 |            |  1 |
|   1 | job_listing_id | INTEGER  |       1 |            |  0 |
|   2 | tag_id         | INTEGER  |       1 |            |  0 |
|   3 | created_at     | datetime |       0 |            |  0 |
|   4 | updated_at     | datetime |       0 |            |  0 |


@see [[https://readouble.com/laravel/12.x/ja/migrations.html#toggling-foreign-key-constraints][外部キー制約の切り替え]]

#+begin_quote
⚠ Warning! SQLiteは、デフォルトで外部キー制約を無効にします。SQLiteを使用する場合は、マイグレーションでデータベースを作成する前に、データベース設定の外部キーサポートを有効にするを確実に行ってください。
#+end_quote


ビデオでは、Tableの定義に、foreign key の表記が見られたが出てこなかった。うまく更新できていないのかもしれない。

#+begin_src bash :tangle no :results org
 test "lara1" = $(basename $(echo $PWD)) && artisan migrate:refresh
#+end_src

#+RESULTS:
#+begin_src org

   INFO  Rolling back migrations.

  2025_10_22_005338_create_tags_table ........................... 22.43ms DONE
  2025_10_16_174339_create_employers_table ....................... 6.47ms DONE
  2025_10_16_013633_create_posts_table ........................... 6.79ms DONE
  2025_10_15_225729_create_job_listings_table .................... 6.80ms DONE
  0001_01_01_000002_create_jobs_table ........................... 20.68ms DONE
  0001_01_01_000001_create_cache_table .......................... 13.82ms DONE
  0001_01_01_000000_create_users_table .......................... 20.78ms DONE


   INFO  Running migrations.

  0001_01_01_000000_create_users_table .......................... 43.47ms DONE
  0001_01_01_000001_create_cache_table .......................... 13.96ms DONE
  0001_01_01_000002_create_jobs_table ........................... 37.01ms DONE
  2025_10_15_225729_create_job_listings_table ................... 10.84ms DONE
  2025_10_16_013633_create_posts_table ........................... 6.95ms DONE
  2025_10_16_174339_create_employers_table ....................... 7.90ms DONE
  2025_10_22_005338_create_tags_table ........................... 15.88ms DONE

#+end_src

以下の設定が必要らしい
#+begin_example
PRAGMA foreign_keys=on;
#+end_example



#+begin_src bash :results raw drawer :tangle yes :eval no-export
sqlite3 ./database/database.sqlite <<EOF
.mode table
PRAGMA pragma_list;
.quit
EOF
#+end_src


#+begin_example
+---------------------------+
|           name            |
+---------------------------+
| analysis_limit            |
| application_id            |
| auto_vacuum               |
| automatic_index           |
| busy_timeout              |
| cache_size                |
| cache_spill               |
| case_sensitive_like       |
| cell_size_check           |
| checkpoint_fullfsync      |
| collation_list            |
| compile_options           |
| count_changes             |
| data_version              |
| database_list             |
| default_cache_size        |
| defer_foreign_keys        |
| empty_result_callbacks    |
| encoding                  |
| foreign_key_check         |
| foreign_key_list          |
| foreign_keys              | # <-----
| freelist_count            |
| full_column_names         |
| fullfsync                 |
| function_list             |
| hard_heap_limit           |
| ignore_check_constraints  |
| incremental_vacuum        |
| index_info                |
| index_list                |
| index_xinfo               |
| integrity_check           |
| journal_mode              |
| journal_size_limit        |
| legacy_alter_table        |
| locking_mode              |
| max_page_count            |
| mmap_size                 |
| module_list               |
| optimize                  |
| page_count                |
| page_size                 |
| pragma_list               |
| query_only                |
| quick_check               |
| read_uncommitted          |
| recursive_triggers        |
| reverse_unordered_selects |
| schema_version            |
| secure_delete             |
| short_column_names        |
| shrink_memory             |
| soft_heap_limit           |
| synchronous               |
| table_info                |
| table_list                |
| table_xinfo               |
| temp_store                |
| temp_store_directory      |
| threads                   |
| trusted_schema            |
| user_version              |
| wal_autocheckpoint        |
| wal_checkpoint            |
| writable_schema           |
+---------------------------+
#+end_example


* クッションテーブルの必要性
<2025-10-22 Wed>

why laravel belongsToMany implements needs cushion table

Googleに上記質問を投げかけた。

ピボットテーブル、または「クッションテーブル」は、belongsToMany多対多の関係を解決するための標準的なデータベースレベルのソリューションであるため、この中間テーブルは多対多の関係に使用されます。この中間テーブルがなければ、2つのテーブルのみを使用してデータを正しく表現することは不可能です。

** ピボットテーブルが多対多の問題を解決する方法
~Users~ 次のような典型的な多対多の関係を想像してください ~Roles~ 。
- 1 人のユーザーが複数の役割を持つことができます。
- 1 つのロールを複数のユーザーに割り当てることができます。
この関係は、データベースの正規化ルールに違反することなく、2 つのテーブル (~users~ と ~roles~) だけで直接表現することはできません。

** 問題のある解決策（そしてそれが失敗する理由）
**** オプション1：テーブルrole_idに列を追加しますusers。
これにより1対多の関係が作成されますが、ユーザーは を1つしか持つことができませんrole_id。2つ目のロールを追加するには、 などの別の列を追加する必要がありますがrole_id_2、これはスケーラブルではありません。

**** オプション2：テーブルuser_idに列を追加するroles。
同様に、各ロールは1人のユーザーにしかリンクできないため、この方法も失敗します。別のユーザーにリンクするには、別の列を追加する必要があり ~user_id~ 、これもスケーラブルではありません。

** ピボットテーブルを使ったソリューション
**** ピボットrole_userテーブル。
3つ目の中間テーブル ~role_user~ が作成されます。
このテーブルには、両方のテーブルの外部キー（ ~role_id~ と）が含まれます ~user_id~ 。
**** ピボットrole_userテーブル（続き）。
各接続を個別の行として保存することで、ピボットテーブルでは無制限の組み合わせが可能になります。例えば、ユーザーは（）と（ ）のどちら1にもなり得ます。adminrole_id: 1moderatorrole_id:


*** 2ピボットテーブルを使用する利点
**** データの整合性と正規化
ピボットテーブルは、テーブルusersとrolesテーブルを「クリーン」に保ち、それぞれのデータに焦点を当てます。データベースのベストプラクティスに従い、関係データを専用のテーブルに分離します。

**** 追加のメタデータを保存
2つのモデル間の関係は、単なる接続以上のものであることがよくあります。
ピボットテーブルには、特定の接続に関連する追加の列を保存できます。例えば、ロールが割り当てられた時点の列やタイムスタンプをuser_roleテーブルに保存できます。status

**** 強力なEloquent機能
LaravelのbelongsToManyリレーションシップとそれに関連するメソッド（attach()、detach()、 などsync()）は、この中間テーブルを自動的に管理するために特別に構築されています。これにより、コード内で簡潔で表現力豊かな構文を記述でき、リレーションシップを手動で管理する際の複雑さを抽象化できます。

* 双方向のオブジェクトの取得

** メソッドの追加

テーブル名衝突回避のため、規約を破っているのでここでも例外的な修正が必要
#+begin_src diff
modified   app/Models/Job.php
@@ -20,6 +20,6 @@ public function employer()
 
     public function tags()
     {
-        return $this->belongsToMany(Tag::class);
+        return $this->belongsToMany(Tag::class, foreignPivotKey: 'job_listing_id');
     }
 }
modified   app/Models/Tag.php
@@ -12,6 +12,6 @@ class Tag extends Model
 
     function jobs()
     {
-        $this->belongsToMany(Tag::class);
+        return $this->belongsToMany(Job::class, relatedPivotKey: 'job_listing_id');
     }
 }
#+end_src

** 呼び出し方による値の変化

#+begin_example
> get_class($tag->jobs);
= "Illuminate\Database\Eloquent\Collection"

> get_class($tag);
= "App\Models\Tag"

> get_class($tag->jobs());
= "Illuminate\Database\Eloquent\Relations\BelongsToMany"

> get_class($tag->jobs()->get());
= "Illuminate\Database\Eloquent\Collection"
#+end_example

#+begin_example
> $tag->jobs;
= Illuminate\Database\Eloquent\Collection {#6580
    all: [
      App\Models\Job {#6559
        id: 10,
        employer_id: 10,
        title: "Hotel Desk Clerk",
        salary: "$50,000 USD",
        created_at: "2025-10-22 07:59:41",
        updated_at: "2025-10-22 07:59:41",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6561
          tag_id: 1,
          job_listing_id: 10,
        },
      },
    ],
  }

#+end_example

#+begin_example
> $tag->jobs();
= Illuminate\Database\Eloquent\Relations\BelongsToMany {#6578
    +withTimestamps: false,
  }
#+end_example

* TagにJobを追加する
#+begin_example
> $tag->jobs()->attach(App\Models\Job::find(7));
= null

#+end_example

#+begin_src bash :results raw code output :tangle yes :eval no-export :exports results
sqlite3 ./database/database.sqlite <<EOF
.mode table
PRAGMA table_info(job_tag);
.quit
EOF
#+end_src

#+RESULTS:
#+begin_src bash
+-----+----------------+----------+---------+------------+----+
| cid |      name      |   type   | notnull | dflt_value | pk |
+-----+----------------+----------+---------+------------+----+
| 0   | id             | INTEGER  | 1       |            | 1  |
| 1   | job_listing_id | INTEGER  | 1       |            | 0  |
| 2   | tag_id         | INTEGER  | 1       |            | 0  |
| 3   | created_at     | datetime | 0       |            | 0  |
| 4   | updated_at     | datetime | 0       |            | 0  |
+-----+----------------+----------+---------+------------+----+
#+end_src


#+begin_example
+-----+----------------+----------+---------+------------+----+
| cid |      name      |   type   | notnull | dflt_value | pk |
+-----+----------------+----------+---------+------------+----+
| 0   | id             | INTEGER  | 1       |            | 1  |
| 1   | job_listing_id | INTEGER  | 1       |            | 0  |
| 2   | tag_id         | INTEGER  | 1       |            | 0  |
| 3   | created_at     | datetime | 0       |            | 0  |
| 4   | updated_at     | datetime | 0       |            | 0  |
+-----+----------------+----------+---------+------------+----+
#+end_example


* その他のリンク
- [[https://medium.com/@emmanuelfortuna68/belongstomany-in-laravel-8401b4f533aa][BelongsToMany in Laravel]]
